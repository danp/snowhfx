<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Halifax Sidewalk and Cycling Snow Clearing</title>
  <meta name="description" content="Map of Halifax sidewalk and cycling snow clearing priorities and deadlines." />
  <meta property="og:title" content="Halifax Sidewalk and Cycling Snow Clearing" />
  <meta property="og:description" content="Map of Halifax sidewalk and cycling snow clearing priorities and deadlines." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://snowhfx.danp.net/" />
  <meta name="twitter:title" content="Halifax Sidewalk and Cycling Snow Clearing" />
  <meta name="twitter:description" content="Map of Halifax sidewalk and cycling snow clearing priorities and deadlines." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50' font-size='50'%3E%E2%9D%84%EF%B8%8F%3C/text%3E%3C/svg%3E" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      display: flex;
      flex-direction: column;
    }
    /* Ensure the map is fully responsive */
    #map {
      width: 100%;
      flex: 1 1 auto;
    }
    :root {
      --header-bg: #f4f4f4;
      --header-border: #ddd;
      --text-primary: #222;
      --text-muted: #333;
      --control-bg: #fff;
      --control-border: #aaa;
      --toggle-active: #3C4A5D;
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --header-bg: #1b1f24;
        --header-border: #2a3038;
        --text-primary: #e6e8eb;
        --text-muted: #c9ced6;
        --control-bg: #222831;
        --control-border: #3a424d;
        --toggle-active: #5b6b80;
      }
    }
    /* Header styling */
    .header {
      padding: 10px;
      background-color: var(--header-bg);
      border-bottom: 1px solid var(--header-border);
      font-family: Arial, sans-serif;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 24px;
      flex-wrap: wrap;
      color: var(--text-primary);
    }
    .mobile-controls {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
    }
    .quick-toggle {
      display: inline-flex;
      border: 1px solid var(--control-border);
      border-radius: 6px;
      overflow: hidden;
    }
    .quick-toggle button {
      border: 0;
      background: var(--control-bg);
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      color: var(--text-primary);
      font-weight: 500;
    }
    .quick-toggle button.is-active {
      background: var(--toggle-active);
      color: #fff;
      font-weight: 700;
    }
    .gear-toggle {
      border: 1px solid var(--control-border);
      border-radius: 6px;
      background: var(--control-bg);
      padding: 4px 8px;
      font-size: 14px;
      cursor: pointer;
      display: none;
      color: var(--text-primary);
    }
    .about-toggle {
      border: 1px solid var(--control-border);
      border-radius: 6px;
      background: var(--control-bg);
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      color: var(--text-primary);
    }
    .skip-link {
      position: absolute;
      top: 8px;
      left: 8px;
      padding: 6px 10px;
      background: var(--control-bg);
      color: var(--text-primary);
      border: 1px solid var(--control-border);
      border-radius: 6px;
      text-decoration: none;
      transform: translateY(-200%);
      transition: transform 0.2s ease;
      z-index: 1000;
    }
    .skip-link:focus {
      transform: translateY(0);
    }
    .quick-toggle button:focus-visible,
    .gear-toggle:focus-visible,
    .about-toggle:focus-visible {
      outline: 2px solid #017A74;
      outline-offset: 2px;
    }
    @media (prefers-color-scheme: dark) {
      .quick-toggle button:focus-visible,
      .gear-toggle:focus-visible,
      .about-toggle:focus-visible {
        outline-color: #78c2b7;
      }
    }
    .priorities {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }
    .priority-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 10px 6px 30px;
      border-radius: 6px;
      position: relative;
      color: #fff;
    }
    .priority-square {
      display: none;
    }
    .priority-item::before {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-weight: bold;
      font-size: 12px;
      letter-spacing: 0.4px;
      opacity: 0.95;
    }
    .priority-1 .priority-square {
      background-color: #017A74;
    }
    .priority-2 .priority-square {
      background-color: #E66101;
    }
    .priority-3 .priority-square {
      background-color: #6B3FA0;
    }
    .priority-1 {
      background-color: #017A74;
    }
    .priority-2 {
      background-color: #E66101;
    }
    .priority-3 {
      background-color: #6B3FA0;
    }
    .priority-1::before {
      content: "P1";
    }
    .priority-2::before {
      content: "P2";
    }
    .priority-3::before {
      content: "P3";
    }
    .priority-deadline {
      font-size: 14px;
      color: #fff;
    }
    .about-panel {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      padding: 16px;
    }
    .about-panel.is-open {
      display: flex;
    }
    .about-card {
      background: var(--control-bg);
      color: var(--text-primary);
      border: 1px solid var(--header-border);
      border-radius: 10px;
      max-width: 560px;
      width: 100%;
      padding: 16px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .about-card h2 {
      font-size: 14px;
      margin: 0 0 8px;
    }
    .about-card p {
      margin: 6px 0;
      color: var(--text-muted);
    }
    .about-card a {
      color: inherit;
    }
    .about-actions {
      margin-top: 12px;
      display: flex;
      justify-content: flex-end;
    }
    .about-close {
      border: 1px solid var(--control-border);
      border-radius: 6px;
      background: var(--control-bg);
      padding: 4px 10px;
      font-size: 12px;
      cursor: pointer;
      color: var(--text-primary);
    }
    .report-panel {
      position: fixed;
      inset: 0;
      background: rgba(7, 10, 12, 0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2100;
      padding: 16px;
    }
    .report-panel.is-open {
      display: flex;
    }
    .report-card {
      background: var(--control-bg);
      color: var(--text-primary);
      border: 1px solid var(--header-border);
      border-radius: 14px;
      max-width: 620px;
      width: 100%;
      padding: 18px;
      font-family: Arial, sans-serif;
      font-size: 13px;
      line-height: 1.4;
      box-shadow: 0 18px 40px rgba(0, 0, 0, 0.25);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .report-header h2 {
      font-size: 16px;
      margin: 0 0 4px;
    }
    .report-subtitle {
      margin: 0;
      color: var(--text-muted);
    }
    .report-form {
      display: grid;
      gap: 12px;
    }
    .report-field label {
      display: block;
      font-weight: 600;
      margin-bottom: 6px;
    }
    .report-textarea {
      border: 1px solid var(--control-border);
      border-radius: 10px;
      padding: 8px 10px;
      min-height: 80px;
      font-family: inherit;
      font-size: 13px;
      color: var(--text-primary);
      background: var(--control-bg);
      width: 100%;
      box-sizing: border-box;
    }
    .report-email-body {
      border: 1px solid var(--control-border);
      border-radius: 10px;
      padding: 8px 10px;
      min-height: 120px;
      font-family: inherit;
      font-size: 12px;
      color: var(--text-primary);
      background: var(--control-bg);
      width: 100%;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .report-footer {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 12px;
      flex-wrap: wrap;
    }
    .report-actions {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .report-email-link {
      border: 1px solid #0f786f;
      border-radius: 8px;
      background: #0f786f;
      color: #fff;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .report-copy {
      border: 1px solid var(--control-border);
      border-radius: 8px;
      background: var(--control-bg);
      color: var(--text-primary);
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .report-close {
      border: 1px solid var(--control-border);
      border-radius: 8px;
      background: var(--control-bg);
      color: var(--text-primary);
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }
    .report-status-message {
      font-size: 12px;
      color: #0f786f;
      font-weight: 600;
      flex: 1 1 100%;
      min-height: 16px;
    }
    .popup-311-button {
      margin-top: 8px;
      border: 1px solid #0f786f;
      border-radius: 8px;
      background: #0f786f;
      color: #fff;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 600;
    }
    .leaflet-popup-content-wrapper,
    .leaflet-popup-tip {
      background: var(--control-bg);
      color: var(--text-primary);
      border: 1px solid var(--header-border);
    }
    .leaflet-popup-content-wrapper a {
      color: var(--text-primary);
    }
    @media (max-width: 480px) {
      .header {
        gap: 12px;
      }
      .priorities {
        width: 100%;
        justify-content: center;
      }
      .priority-item {
        flex: 0 1 auto;
      }
      .priority-deadline {
        text-align: center;
      }
      .gear-toggle {
        display: inline-flex;
      }
      .priority-item {
        padding: 6px 8px;
      }
      .priority-deadline {
        font-weight: bold;
      }
      .priority-item::before {
        content: "";
      }
      body.mobile-expanded .priority-item {
        padding: 6px 8px 6px 28px;
      }
      body.mobile-expanded .priority-1::before {
        content: "P1";
      }
      body.mobile-expanded .priority-2::before {
        content: "P2";
      }
      body.mobile-expanded .priority-3::before {
        content: "P3";
      }
      .about-toggle {
        display: none;
      }
      body.mobile-expanded .about-toggle {
        display: inline-flex;
      }
      .report-email-body {
        min-height: 140px;
      }
    }
    @media (prefers-reduced-motion: reduce) {
      .skip-link {
        transition: none;
      }
    }
  </style>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
</head>
<body>
  <a class="skip-link" href="#map">Skip to map</a>
  <div class="header">
    <div class="priorities" id="priorities-header"></div>
    <div class="mobile-controls" id="mobile-controls">
      <button class="about-toggle" id="about-toggle" type="button" aria-expanded="false" aria-controls="about-panel">About</button>
      <div class="quick-toggle" role="group" aria-label="Map mode">
        <button type="button" data-mode="sidewalks" data-short="S" data-full="Sidewalks" aria-label="Sidewalks">S</button>
        <button type="button" data-mode="cycling" data-short="C" data-full="Cycling" aria-label="Cycling">C</button>
      </div>
      <button class="gear-toggle" id="gear-toggle" type="button" aria-label="More options">⚙</button>
    </div>
  </div>
  <div id="map" role="region" aria-label="Map of Halifax snow clearing priorities for sidewalks and cycling routes"></div>
  <div class="about-panel" id="about-panel" aria-hidden="true">
    <div class="about-card" role="dialog" aria-modal="true" aria-labelledby="about-title">
      <h2 id="about-title">About</h2>
      <p>
        Service updates are sourced from
        <a href="https://www.halifax.ca/transportation/winter-operations/service-updates" target="_blank" rel="noopener">Winter Operations Service Updates</a>
        (updated about hourly). Clearing deadlines are based on that page.
      </p>
      <p>
        Priority definitions for streets and sidewalks are described on
        <a href="https://www.halifax.ca/transportation/winter-operations/snow-clearing-service-standards" target="_blank" rel="noopener">Snow Clearing Service Standards</a>.
      </p>
      <p>
        Sidewalks, multi-use paths, etc. are sourced from the
        <a href="https://data-hrm.hub.arcgis.com/datasets/a3631c7664ef4ecb93afb1ea4c12022b_0/explore" target="_blank" rel="noopener">Active Travelways</a>
        dataset.
      </p>
      <p>
        Cycling infrastructure and routes are sourced from the
        <a href="https://data-hrm.hub.arcgis.com/datasets/HRM::bike-infrastructure-and-suggested-routes/explore" target="_blank" rel="noopener">Bike Infrastructure and Suggested Routes</a> dataset.
        Routes contain painted bike lanes, multi-use pathways, and shared roadways, some of which are not necessarily "infrastructure."
        Some routes are missing or excluded if they are not part of that dataset or aren't plowed by HRM.
        Priorities are assigned by matching to nearby Active Travelways or
        <a href="https://data-hrm.hub.arcgis.com/datasets/HRM::ice-routes/explore" target="_blank" rel="noopener">Ice Routes</a>,
        with unmatched lines omitted.
      </p>
      <p>
        Read more about the development in
        <a href="https://danp.net/posts/halifax-sidewalk-snow-clearing-map/" target="_blank" rel="noopener">this blog post</a>
        or browse the code on
        <a href="https://github.com/danp/snowhfx" target="_blank" rel="noopener">GitHub</a>.
      </p>
      <div class="about-actions">
        <button class="about-close" id="about-close" type="button">Close</button>
      </div>
    </div>
  </div>
  <div class="report-panel" id="report-panel" aria-hidden="true">
    <div class="report-card" role="dialog" aria-modal="true" aria-labelledby="report-title">
      <div class="report-header">
        <h2 id="report-title">Report to 311</h2>
        <p class="report-subtitle">Email contactus@311.halifax.ca about a missed clearing deadline.</p>
      </div>
      <div class="report-form" id="report-form">
        <div class="report-field">
          <label for="report-notes">What's wrong? (optional)</label>
          <textarea class="report-textarea" id="report-notes" name="notes" placeholder="Add details like blocked curb cuts, ice buildup, or when you checked."></textarea>
        </div>
        <div class="report-field">
          <label id="report-email-body-label">Email draft</label>
          <pre class="report-email-body" id="report-email-body" aria-labelledby="report-email-body-label"></pre>
        </div>
        <div class="report-footer">
          <span class="report-status-message" id="report-status-message" aria-live="polite"></span>
          <div class="report-actions">
            <a class="report-email-link" id="report-email-link" href="#" target="_blank" rel="noopener">Email 311</a>
            <button class="report-copy" id="report-copy-body" type="button">Copy body</button>
            <button class="report-close" id="report-close" type="button">Close</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // Initialize the Leaflet map.
    var map = L.map('map', { preferCanvas: true });

    // Save and load the map state (center and zoom) to localStorage.
    function saveMapState(map) {
      savedState = {
        center: map.getCenter(),
        zoom: map.getZoom()
      };
      localStorage.setItem('mapState', JSON.stringify(savedState));
    }
    function loadMapState() {
      const saved = JSON.parse(localStorage.getItem('mapState'));
      return saved ? { center: [saved.center.lat, saved.center.lng], zoom: saved.zoom } : null;
    }
    let savedState = loadMapState();

    // Add an OpenStreetMap basemap.
    const lightTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    });
    const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      attribution:
        '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>'
    });

    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
    function setBasemap(isDark) {
      if (isDark) {
        map.removeLayer(lightTiles);
        darkTiles.addTo(map);
      } else {
        map.removeLayer(darkTiles);
        lightTiles.addTo(map);
      }
    }
    setBasemap(prefersDark.matches);
    if (prefersDark.addEventListener) {
      prefersDark.addEventListener('change', (event) => setBasemap(event.matches));
    } else if (prefersDark.addListener) {
      prefersDark.addListener((event) => setBasemap(event.matches));
    }

    // Format a deadline date for display.
    function formatDeadline(deadline) {
      if (!deadline) return "Pending";
      const d = new Date(deadline);
      const now = new Date();
      const trimMinutes = (value) => value.replace(':00 ', ' ');
      if (d > now - (3 * 86400 * 1000)) {
        return trimMinutes(d.toLocaleString('en-US', { weekday: 'short', hour: 'numeric', minute: '2-digit' }));
      }
      return trimMinutes(d.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }));
    }

    /**
     * Decode segmented features from the binary file.
     *
     * Expected binary layout:
     * - uint32: numberOfSegments
     * - float64: globalBaseLon
     * - float64: globalBaseLat
     * - uint16: numberOfRoutes
     *   - uint8: maintLength
     *   - [maintLength] bytes: WINT_MAINT string
     *   - uint8: routeLength
     *   - [routeLength] bytes: WINT_ROUTE string
     *
     * For each segment:
     *   - int32: segDeltaMinLon
     *   - int32: segDeltaMinLat
     *   - int32: segDeltaMaxLon
     *   - int32: segDeltaMaxLat
     *   - uint32: numberOfFeaturesInSegment
     *
     *   For each feature:
     *     - uint8: titleLength
     *     - [titleLength] bytes: title string
     *     - uint8: priority
     *     - uint8: sourceDataset
     *     - uint16: routeID (0 = none)
     *     - uint16: coordinateCount
     *     - For each coordinate:
     *         - int32: deltaLon
     *         - int32: deltaLat
     *
     * (All delta values are relative to the global base and use a multiplier of 1e6.)
     */
    async function decodeSegmentedFeatures(arrayBuffer) {
      const dataView = new DataView(arrayBuffer);
      let offset = 0;
      const segmentCount = dataView.getUint32(offset, true);
      offset += 4;
      const baseLon = dataView.getFloat64(offset, true);
      offset += 8;
      const baseLat = dataView.getFloat64(offset, true);
      offset += 8;
      const routeCount = dataView.getUint16(offset, true);
      offset += 2;
      routeTable = [null];
      for (let r = 0; r < routeCount; r++) {
        const maintLength = dataView.getUint8(offset); offset += 1;
        const maint = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset, maintLength));
        offset += maintLength;
        const routeLength = dataView.getUint8(offset); offset += 1;
        const route = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset, routeLength));
        offset += routeLength;
        routeTable.push({ maint, route });
      }

      const segments = [];
      for (let s = 0; s < segmentCount; s++) {
        // Read the segment's bounding box (as deltas from the global base).
        const segDeltaMinLon = dataView.getInt32(offset, true); offset += 4;
        const segDeltaMinLat = dataView.getInt32(offset, true); offset += 4;
        const segDeltaMaxLon = dataView.getInt32(offset, true); offset += 4;
        const segDeltaMaxLat = dataView.getInt32(offset, true); offset += 4;
        const segBounds = L.latLngBounds(
          [baseLat + segDeltaMinLat / 1000000, baseLon + segDeltaMinLon / 1000000],
          [baseLat + segDeltaMaxLat / 1000000, baseLon + segDeltaMaxLon / 1000000]
        );

        // Read the number of features in this segment.
        const numFeatures = dataView.getUint32(offset, true);
        offset += 4;
        const features = [];
        for (let i = 0; i < numFeatures; i++) {
          // Read title.
          const titleLength = dataView.getUint8(offset); offset += 1;
          const title = new TextDecoder().decode(new Uint8Array(arrayBuffer, offset, titleLength));
          offset += titleLength;
          // Read priority.
          const priority = dataView.getUint8(offset); offset += 1;
          const sourceDataset = dataView.getUint8(offset); offset += 1;
          const routeID = dataView.getUint16(offset, true); offset += 2;
          // Read coordinate count.
          const coordCount = dataView.getUint16(offset, true); offset += 2;
          const coords = [];
          for (let j = 0; j < coordCount; j++) {
            const deltaLon = dataView.getInt32(offset, true) / 1000000; offset += 4;
            const deltaLat = dataView.getInt32(offset, true) / 1000000; offset += 4;
            // Leaflet expects [lat, lon].
            coords.push([baseLat + deltaLat, baseLon + deltaLon]);
          }
          features.push({ title, priority, coords, sourceDataset, routeID });
        }
        segments.push({ bounds: segBounds, features });
      }
      return segments;
    }

    // Global storage for segments and rendered segments.
    let allSegments = [];
    let routeTable = [null];
    let reportActions = { openFromFeature: null };
    const featuresLayer = L.layerGroup().addTo(map);
    // Track segments that are currently rendered, keyed by segment index.
    const renderedSegments = {};
    let hasLoadedDataset = false;
    let mapListenersSet = false;
    const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
    const lineWeight = isCoarsePointer ? 9 : 6;
    const lineTolerance = isCoarsePointer ? 12 : 6;

    // Return a color based on feature priority.
    function getPriorityColor(priority) {
      switch (priority) {
        case 1: return '#017A74';
        case 2: return '#E66101';
        case 3: return '#6B3FA0';
        default: return '#CCCCCC';
      }
    }

    const datasetInfo = {
      0: { label: 'Active Travelways', itemId: 'a3631c7664ef4ecb93afb1ea4c12022b_0' },
      1: { label: 'Bike Infrastructure', itemId: '460bba0983504ff9a3d74f144128b1ad_0' },
      2: { label: 'Ice Routes', itemId: 'e9dd1561e22e4a149c5b45f54ec0942d_0' }
    };
    let currentDatasetCode = 0;
    let currentDatasetMode = 'sidewalks';

    function featureMidpoint(coords) {
      if (!coords || coords.length === 0) return null;
      return coords[Math.floor(coords.length / 2)];
    }

    function datasetExploreUrl(datasetCode, coords, zoom) {
      const info = datasetInfo[datasetCode];
      if (!info || !coords) return null;
      const lat = coords[0].toFixed(6);
      const lon = coords[1].toFixed(6);
      const z = (zoom || 21).toFixed(2);
      return `https://data-hrm.hub.arcgis.com/datasets/${info.itemId}/explore?location=${lat}%2C${lon}%2C${z}`;
    }

    function datasetLabel(datasetCode) {
      const info = datasetInfo[datasetCode];
      return info ? info.label : 'Unknown dataset';
    }

    function isDeadlinePassed(details) {
      if (!details || !details.Deadline) return false;
      return new Date() > details.Deadline;
    }

    function travelwayTypeForFeature(feature) {
      if (!feature) return 'Travelway';
      if (currentDatasetMode === 'sidewalks') {
        return 'Sidewalk/path';
      }
      return 'Bikeway/path/street';
    }

    function getPopupContent(segmentIdx, featureIdx) {
      const segment = allSegments[segmentIdx];
      if (!segment) return "Unknown segment";
      const feature = segment.features[featureIdx];
      if (!feature) return "Unknown feature";
      const priorityDetails = window.priorities[feature.priority];
      const midpoint = featureMidpoint(feature.coords);
      const featureLink = datasetExploreUrl(currentDatasetCode, midpoint);
      const sourceLink = datasetExploreUrl(feature.sourceDataset, midpoint);
      const featureLabel = datasetLabel(currentDatasetCode);
      const sourceLabel = datasetLabel(feature.sourceDataset);
      const showSource = feature.sourceDataset !== currentDatasetCode;
      const routeInfo = routeTable[feature.routeID];
      const routeLabel = routeInfo ? [routeInfo.maint, routeInfo.route].filter(Boolean).join(' / ') : '';
      const showReportButton = isDeadlinePassed(priorityDetails);
      return `
        ${feature.title || 'Unknown'}<br>
        <strong>Priority:</strong> ${feature.priority}<br>
        <strong>Deadline:</strong> ${formatDeadline(priorityDetails.Deadline)}<br>
        <strong>Timeline:</strong> ${priorityDetails.Timeline} hours<br>
        ${routeLabel ? `<strong>Winter route:</strong> ${routeLabel}<br>` : ''}
        <strong>Dataset:</strong> ${featureLink ? `<a href="${featureLink}" target="_blank" rel="noopener">${featureLabel}</a>` : featureLabel}
        ${showSource ? `<br><strong>Priority source:</strong> ${sourceLink ? `<a href="${sourceLink}" target="_blank" rel="noopener">${sourceLabel}</a>` : sourceLabel}` : ''}
        ${showReportButton ? `<br><button type="button" class="popup-311-button" data-seg="${segmentIdx}" data-feature="${featureIdx}">Report to 311</button>` : ''}
      `;
    }

    function getRouteLabel(routeID) {
      const info = routeTable[routeID];
      if (!info) return '';
      return [info.maint, info.route].filter(Boolean).join(' / ');
    }

    /**
     * Update which segments are rendered based on the current map viewport.
     * If any part of a segment is visible, all its features are rendered.
     */
    function updateVisibleFeatures() {
      const mapBounds = map.getBounds();
      allSegments.forEach((segment, segmentIdx) => {
        if (mapBounds.intersects(segment.bounds)) {
          // If this segment isn’t rendered yet, add it.
          if (!(segmentIdx in renderedSegments)) {
            const segmentLayer = L.layerGroup();
            segment.features.forEach((feature, featureIdx) => {
              const color = getPriorityColor(feature.priority);
              const priorityDetails = window.priorities[feature.priority];
            const polyline = L.polyline(feature.coords, {
                color,
                weight: lineWeight,
                lineCap: 'round',
                lineJoin: 'round',
                interactive: true,
                tolerance: lineTolerance
              })
                .bindPopup(function() {
                   return getPopupContent(segmentIdx, featureIdx);
                 });
              polyline.addTo(segmentLayer);
            });
            segmentLayer.addTo(featuresLayer);
            renderedSegments[segmentIdx] = segmentLayer;
          }
        } else {
          // If the segment is not visible and is currently rendered, remove it.
          if (segmentIdx in renderedSegments) {
            featuresLayer.removeLayer(renderedSegments[segmentIdx]);
            delete renderedSegments[segmentIdx];
          }
        }
      });
    }

    /**
     * Load and render segmented features from the binary file.
     */
    function resetRenderedFeatures() {
      Object.values(renderedSegments).forEach(layer => featuresLayer.removeLayer(layer));
      for (const key in renderedSegments) {
        delete renderedSegments[key];
      }
      featuresLayer.clearLayers();
      allSegments = [];
    }

    async function loadAndRenderSegmentedFeatures(url, options) {
      const opts = options || {};
      try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        allSegments = await decodeSegmentedFeatures(arrayBuffer);
        if (allSegments.length === 0) {
          console.error("No segments found in the binary file.");
          return;
        }
        // Compute global bounds from all segments.
        const globalBounds = L.latLngBounds();
        allSegments.forEach(segment => globalBounds.extend(segment.bounds));
        if (!opts.preserveView) {
          if (savedState) {
            map.setView(savedState.center, savedState.zoom);
          } else if (opts.fitBounds !== false) {
            map.fitBounds(globalBounds);
          }
        }
        updateVisibleFeatures();
        // Update visible segments when the map moves or zooms.
        if (!mapListenersSet) {
          map.on('moveend', () => {
            saveMapState(map);
            updateVisibleFeatures();
          });
          mapListenersSet = true;
        }
      } catch (error) {
        console.error("Error rendering segmented features:", error);
      }
    }

    // Load priority/timeline data.
    fetch('https://hrm.datasette.danp.net/snow/snowhfx.json?_shape=objects')
      .then(response => response.json())
      .then(data => {
        let state = data.rows[0].state;
        let maxEndTime = data.rows[0].max_end_time;
        if (state === "active") {
          maxEndTime = null;
        }
        const endTime = maxEndTime ? new Date(maxEndTime) : null;
        function calculateDeadline(hours) {
          if (!endTime) return null;
          return new Date(endTime.getTime() + (hours * 3600 * 1000));
        }
        const priorities = {
          1: { Timeline: 12, Deadline: calculateDeadline(12) },
          2: { Timeline: 18, Deadline: calculateDeadline(18) },
          3: { Timeline: 36, Deadline: calculateDeadline(36) }
        };
        // Make priorities available globally.
        window.priorities = priorities;
        // Update the header with priority details.
        const prioritiesHeader = document.getElementById('priorities-header');
        prioritiesHeader.innerHTML = Object.entries(priorities)
          .map(([priority, details]) => `
            <div class="priority-item priority-${priority}">
              <div class="priority-square">${priority}</div>
              <div class="priority-deadline">${formatDeadline(details.Deadline)}</div>
            </div>
          `)
          .join('');
        const mobileControls = document.getElementById('mobile-controls');
        const quickButtons = mobileControls.querySelectorAll('button[data-mode]');
        const gearToggle = document.getElementById('gear-toggle');
        const aboutToggle = document.getElementById('about-toggle');
        const aboutPanel = document.getElementById('about-panel');
        const aboutClose = document.getElementById('about-close');
        const reportPanel = document.getElementById('report-panel');
        const reportClose = document.getElementById('report-close');
        const reportNotes = document.getElementById('report-notes');
        const reportEmailBody = document.getElementById('report-email-body');
        const reportEmailLink = document.getElementById('report-email-link');
        const reportCopyBody = document.getElementById('report-copy-body');
        const reportStatusMessage = document.getElementById('report-status-message');
        let reportFeature = null;
        let reportStreetText = 'Unnamed segment';
        let reportTravelwayType = 'Travelway';
        let reportRouteText = 'Not matched';
        let reportDatasetUrl = 'Not available';
        const datasetConfig = {
          sidewalks: { url: 'features.bin', datasetCode: 0 },
          cycling: { url: 'features_cycling.bin', datasetCode: 1 }
        };
        const storedDataset = localStorage.getItem('datasetMode');
        const initialDataset = datasetConfig[storedDataset] ? storedDataset : 'sidewalks';

        function updateQuickToggle(mode) {
          quickButtons.forEach(button => {
            const active = button.dataset.mode === mode;
            button.classList.toggle('is-active', active);
            button.setAttribute('aria-pressed', active ? 'true' : 'false');
          });
        }

        function updateQuickLabels() {
          quickButtons.forEach(button => {
            button.textContent = button.dataset.full;
          });
        }

        function loadDataset(mode) {
          const config = datasetConfig[mode];
          if (!config) {
            console.error("Unknown dataset:", mode);
            return;
          }
          currentDatasetMode = mode;
          currentDatasetCode = config.datasetCode;
          resetRenderedFeatures();
          const isInitialLoad = !hasLoadedDataset;
          const fitBounds = !savedState && isInitialLoad;
          const preserveView = !isInitialLoad;
          hasLoadedDataset = true;
          loadAndRenderSegmentedFeatures(config.url, { fitBounds, preserveView });
          updateQuickToggle(mode);
        }

        quickButtons.forEach(button => {
          button.addEventListener('click', () => {
            const mode = button.dataset.mode;
            localStorage.setItem('datasetMode', mode);
            loadDataset(mode);
          });
        });
        const storedExpanded = localStorage.getItem('mobileExpanded') === '1';
        if (storedExpanded) {
          document.body.classList.add('mobile-expanded');
        }
        updateQuickLabels();
        gearToggle.addEventListener('click', () => {
          document.body.classList.toggle('mobile-expanded');
          localStorage.setItem('mobileExpanded', document.body.classList.contains('mobile-expanded') ? '1' : '0');
          updateQuickLabels();
        });
        window.addEventListener('resize', updateQuickLabels);

        // Load and render the initial dataset.
        loadDataset(initialDataset);

        function setAboutOpen(isOpen) {
          aboutPanel.classList.toggle('is-open', isOpen);
          aboutPanel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
          aboutToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
          if (isOpen) {
            aboutClose.focus();
          } else {
            aboutToggle.focus();
          }
        }

        aboutToggle.addEventListener('click', () => setAboutOpen(true));
        aboutClose.addEventListener('click', () => setAboutOpen(false));
        aboutPanel.addEventListener('click', (event) => {
          if (event.target === aboutPanel) {
            setAboutOpen(false);
          }
        });
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && aboutPanel.classList.contains('is-open')) {
            setAboutOpen(false);
          }
        });

        function setReportOpen(isOpen) {
          reportPanel.classList.toggle('is-open', isOpen);
          reportPanel.setAttribute('aria-hidden', isOpen ? 'false' : 'true');
          if (isOpen) {
            reportStatusMessage.textContent = '';
            reportClose.focus();
          } else {
            reportNotes.value = '';
            reportFeature = null;
            reportStreetText = 'Unnamed segment';
            reportTravelwayType = 'Travelway';
            reportRouteText = 'Not matched';
            reportDatasetUrl = 'Not available';
          }
        }

        reportClose.addEventListener('click', () => setReportOpen(false));
        reportPanel.addEventListener('click', (event) => {
          if (event.target === reportPanel) {
            setReportOpen(false);
          }
        });
        document.addEventListener('click', (event) => {
          const button = event.target.closest('.popup-311-button');
          if (!button) {
            return;
          }
          const segmentIdx = Number(button.dataset.seg);
          const featureIdx = Number(button.dataset.feature);
          const segment = allSegments[segmentIdx];
          if (!segment || !segment.features || !segment.features[featureIdx]) {
            return;
          }
          if (reportActions.openFromFeature) {
            reportActions.openFromFeature(segment.features[featureIdx]);
          }
          event.preventDefault();
          event.stopPropagation();
        });
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && reportPanel.classList.contains('is-open')) {
            setReportOpen(false);
          }
        });
        function updateReportEmailDraft() {
          if (!reportFeature) {
            return;
          }
          reportStatusMessage.textContent = '';
          const street = reportStreetText;
          const travelwayType = reportTravelwayType;
          const routeLabel = reportRouteText;
          const datasetUrl = reportDatasetUrl;
          const note = reportNotes.value.trim();
          const lines = [
            'Hello 311,',
            '',
            'I am reporting a snow issue for:',
            '',
            `${travelwayType}: ${street}`,
            '',
            `Winter route: ${routeLabel}`,
            '',
            `Open Data map location: ${datasetUrl}`
          ];
          if (note) {
            lines.push('', `Note: ${note}`);
          }
          const body = lines.join('\n');
          const subject = `Snow clearing - ${street}`;
          reportEmailBody.textContent = body;
          reportEmailLink.href = `mailto:contactus@311.halifax.ca?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
        }

        function setReportFromFeature(feature) {
          reportFeature = feature;
          reportStatusMessage.textContent = '';
          const street = feature.title || 'Unnamed segment';
          const travelwayType = travelwayTypeForFeature(feature);
          const routeLabel = feature.routeID ? (getRouteLabel(feature.routeID) || 'Not matched') : 'Not matched';
          reportStreetText = street;
          reportTravelwayType = travelwayType;
          reportRouteText = routeLabel;
          const midpoint = featureMidpoint(feature.coords);
          const datasetUrl = datasetExploreUrl(currentDatasetCode, midpoint);
          reportDatasetUrl = datasetUrl || 'Not available';
          reportNotes.value = '';
          updateReportEmailDraft();
        }

        reportNotes.addEventListener('input', updateReportEmailDraft);
        reportCopyBody.addEventListener('click', async () => {
          reportStatusMessage.textContent = '';
          const text = reportEmailBody.textContent;
          if (!text) {
            reportStatusMessage.textContent = 'Nothing to copy yet.';
            return;
          }
          const fallbackCopy = () => {
            const temp = document.createElement('textarea');
            temp.value = text;
            temp.setAttribute('readonly', '');
            temp.style.position = 'fixed';
            temp.style.top = '0';
            temp.style.left = '0';
            temp.style.width = '1px';
            temp.style.height = '1px';
            temp.style.opacity = '0';
            temp.style.fontSize = '16px';
            document.body.appendChild(temp);
            temp.select();
            temp.setSelectionRange(0, text.length);
            const ok = document.execCommand('copy');
            document.body.removeChild(temp);
            return ok;
          };
          try {
            if (navigator.clipboard && window.isSecureContext) {
              await navigator.clipboard.writeText(text);
              reportStatusMessage.textContent = 'Copied email body.';
              return;
            }
            if (fallbackCopy()) {
              reportStatusMessage.textContent = 'Copied email body.';
            } else {
              reportStatusMessage.textContent = 'Copy failed. You can select and copy the text.';
            }
          } catch (error) {
            console.error('Unable to copy email body', error);
            reportStatusMessage.textContent = 'Copy failed. You can select and copy the text.';
          }
        });
        reportActions.openFromFeature = (feature) => {
          setReportFromFeature(feature);
          setReportOpen(true);
        };
      })
      .catch(error => console.error("Error loading priorities:", error));
  </script>
  <script>
    window.goatcounter = {
        path: function(p) { return location.host + p }
    }
  </script>
  <script data-goatcounter="https://s.danp.net/count" async src="//s.danp.net/count.js"></script>
</body>
</html>
